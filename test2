import time
import requests
import logging
import os
from requests.adapters import HTTPAdapter, Retry
from typing import Dict, Any, Optional
from time import perf_counter

from app.config import settings
from app.llm.telemetry import get_llm_telemetry
from app.observability.metrics import estimate_tokens

logger = logging.getLogger("pcp_app")

# ------------------------------------------------------------------
# Timeouts & retry policy (driven by env, no new hardcoding)
# ------------------------------------------------------------------
DEFAULT_TIMEOUT = float(os.getenv("HORIZON_TIMEOUT_SECONDS", "30"))
RETRY_TOTAL = int(os.getenv("HORIZON_RETRY_TOTAL", "3"))
RETRY_BACKOFF = float(os.getenv("HORIZON_RETRY_BACKOFF", "0.5"))

# If you have CA bundle configured, use it; else follow your existing logic.
verify_val = settings.CA_BUNDLE_PATH if settings.VERIFY_SSL_SOAP else False

# ------------------------------------------------------------------
# Token cache (memory)
# ------------------------------------------------------------------
_token_cache: Dict[str, Any] = {
    "access_token": None,
    "expires_at": 0.0,  # epoch seconds
}

# (Keeping as-is even if currently unused elsewhere)
_member_token_cache: Dict[str, Any] = {
    "access_token": None,
    "expires_at": 0.0,
}

# ------------------------------------------------------------------
# Shared session (so retries/pooling are actually used)
# ------------------------------------------------------------------
_SESSION: Optional[requests.Session] = None


def _auth_endpoint() -> str:
    """Build Horizon OAuth token endpoint."""
    if not settings.HORIZON_GATEWAY:
        raise ValueError("HORIZON_GATEWAY is not set")
    return f"{settings.HORIZON_GATEWAY}/oauth2/token"


def _session_with_retries() -> requests.Session:
    """Requests session with basic retry policy suitable for gateways."""
    session = requests.Session()
    retry = Retry(
        total=RETRY_TOTAL,
        connect=RETRY_TOTAL,
        read=RETRY_TOTAL,
        backoff_factor=RETRY_BACKOFF,
        status_forcelist=(429, 500, 502, 503, 504),
        allowed_methods=frozenset(["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]),
        raise_on_status=False,
        respect_retry_after_header=True,
    )
    adapter = HTTPAdapter(max_retries=retry, pool_connections=10, pool_maxsize=10)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    return session


def _get_session() -> requests.Session:
    global _SESSION
    if _SESSION is None:
        _SESSION = _session_with_retries()
    return _SESSION


def _get_timeout_seconds() -> float:
    """
    Timeout resolution order (no hardcoding):
    - settings.HORIZON_TIMEOUT (if you have it)
    - settings.DEFAULT_TIMEOUT (if you have it)
    - env DEFAULT_TIMEOUT (HORIZON_TIMEOUT_SECONDS)
    """
    t = getattr(settings, "HORIZON_TIMEOUT", None)
    if isinstance(t, (int, float)) and t > 0:
        return float(t)

    t = getattr(settings, "DEFAULT_TIMEOUT", None)
    if isinstance(t, (int, float)) and t > 0:
        return float(t)

    return float(DEFAULT_TIMEOUT)


def call_horizon(system_prompt: str, user_prompt: str) -> str:
    """
    Call Horizon chat endpoint using retries + timeout.
    Keeps telemetry behavior. Does NOT alter LangGraph flow.
    """
    auth_token = getAuthToken(
        settings.HORIZON_CLIENT_ID,
        settings.HORIZON_CLIENT_SECRET,
        settings.HORIZON_GATEWAY,
    )

    url = f"{settings.HORIZON_CHAT_ENDPOINT}"
    timeout = _get_timeout_seconds()
    session = _get_session()

    t0 = perf_counter()
    telemetry = get_llm_telemetry()
    if telemetry is not None:
        telemetry["llm_prompt_tokens"] = telemetry.get("llm_prompt_tokens", 0) + estimate_tokens(system_prompt) + estimate_tokens(user_prompt)

    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {auth_token}",
    }
    payload = {
        "messages": [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ],
        "stream": False,
    }

    out_text = ""
    try:
        # IMPORTANT: use the session so retries apply
        resp = session.post(url, headers=headers, json=payload, timeout=timeout, verify=verify_val)
        resp.raise_for_status()

        data = resp.json()
        content = None

        # Your existing extraction logic (kept)
        if isinstance(data, dict):
            msg = data.get("message")
            if isinstance(msg, dict):
                content = msg.get("content")

            # fallback shapes
            if content is None and "choices" in data and data["choices"]:
                choice = data["choices"][0]
                m = choice.get("message") or {}
                content = m.get("content")

            if content is None and isinstance(data.get("text"), str):
                content = data["text"]

        # Some backends send list-of-parts
        if isinstance(content, list):
            content = "".join(
                part.get("text", "") if isinstance(part, dict) else str(part)
                for part in content
            )

        out_text = content.strip() if isinstance(content, str) else str(data)

        if telemetry is not None:
            telemetry["llm_completion_tokens"] = telemetry.get("llm_completion_tokens", 0) + estimate_tokens(out_text)

        return out_text

    finally:
        if telemetry is not None:
            telemetry["llm_latency_ms"] = telemetry.get("llm_latency_ms", 0.0) + (perf_counter() - t0) * 1000.0


def getAuthToken(client_id: str, client_secret: str, address: str) -> str:
    """
    Get (and cache) a Horizon Bearer token via client_credentials.
    - Respects in-memory cache until expiry (with a small safety margin).
    """
    now = time.time()
    if _token_cache["access_token"] and now < _token_cache["expires_at"] - 10:
        return _token_cache["access_token"]

    if not address:
        raise ValueError("Horizon address is required (HORIZON_GATEWAY).")
    if not client_id or not client_secret:
        raise ValueError("Horizon client_id/client_secret are required.")

    url = _auth_endpoint()
    data = {
        "grant_type": "client_credentials",
        "client_id": client_id,
        "client_secret": client_secret,
    }
    headers = {"Content-Type": "application/x-www-form-urlencoded"}

    session = _get_session()
    timeout = _get_timeout_seconds()

    try:
        resp = session.post(url, data=data, headers=headers, timeout=timeout, verify=verify_val)
        resp.raise_for_status()
        payload = resp.json()

        access_token = payload.get("access_token")
        expires_in = payload.get("expires_in", 3600)
        if not access_token:
            raise ValueError(f"Token endpoint missing 'access_token'. Response: {payload}")

        _token_cache["access_token"] = access_token
        _token_cache["expires_at"] = time.time() + float(expires_in)
        return access_token

    except requests.RequestException as e:
        logger.error("Horizon token request failed: %s", e, exc_info=True)
        raise
    except ValueError as e:
        logger.error("Invalid token response: %s", e, exc_info=True)
        raise
