def node_run_specialist_generic_search(state: PCPState) -> PCPState:
    """
    Specialist flow:
    - Use stored specialist_service_specialty
    - Parse specialist_raw_filter_input (any combo)
    - Apply defaults (distance from CSV for Specialist + today's YYYYMMDD if date missing)
    - Call provider_generic_search(serviceSpecialty=...)
    - Return provider grid JSON in AIResponse (AURA, 107), PromptTitle/Prompts empty
    """
    logger.debug("node_run_specialist_generic_search")

    # If already have results, don't re-run
    if state.get("providers_result"):
        return state

    group_id = (state.get("group_id") or "").strip()
    subscriber_id = (state.get("subscriber_id") or "").strip()
    specialty = (state.get("specialist_service_specialty") or "").strip()

    if not group_id or not subscriber_id:
        state["ai_response"] = "Member details are missing (groupId/subscriberId). Please start a new conversation."
        state["ai_response_type"] = "AURA"
        state["ai_response_code"] = 500
        state["prompt_title"] = ""
        state["prompts"] = []
        state["stage"] = "ERROR"
        return state

    if not specialty:
        state["ai_response"] = "Service specialty code is missing. Please enter the service specialty code."
        state["ai_response_type"] = "AURA"
        state["ai_response_code"] = 109
        state["prompt_title"] = ""
        state["prompts"] = []
        state["stage"] = "ASK_SPECIALTY"
        return state

    # Defaults
    default_radius = get_default_radius_in_miles(group_id=group_id, practitioner_type="Specialist")
    today_yyyymmdd = datetime.now().strftime("%Y%m%d")

    raw_text = (state.get("specialist_raw_filter_input") or "").strip()
    parsed = llm_parse_specialist_filters(raw_text)
    print("parsed: ",parsed)
    radius = int(default_radius)
    provider_lang = ""
    provider_sex = ""
    zip_code = ""
    as_of_date = today_yyyymmdd

    if parsed.get("use_defaults"):
        # keep defaults only
        pass
    else:
        # language -> providerLanguage
        provider_lang = map_language_to_code(parsed.get("language"))

        # gender -> providerSex (M/F only)
        g = parsed.get("gender")
        if g in ("M", "F"):
            provider_sex = g

        # zip -> startingLocationZip
        z = parsed.get("zip")
        if z and str(z).isdigit() and len(str(z)) == 5:
            zip_code = str(z)

        # date -> asOfDate (YYYYMMDD)
        d = parsed.get("as_of_date")
        if isinstance(d, str) and d.strip():
            as_of_date = d.strip()

        # radius override
        r = parsed.get("radius_in_miles")
        if isinstance(r, (int, float)) and r > 0:
            radius = int(r)

    try:
        # IMPORTANT: provider_generic_search must accept these named params
        mark_api(state, provider_generic_search)
        providers = provider_generic_search(
            group_id=group_id,
            subscriber_id=subscriber_id,
            radius_in_miles=radius,
            startingLocationZip=zip_code,
            asOfDate=as_of_date,
            providerLanguage=provider_lang,
            providerSex=provider_sex,
            serviceSpecialty=specialty,
        ) 
    except ProviderSearchAPIError as e:
        # Show backend detail to user
        state["providers_result"] = []
        state["ai_response"] = e.message  # <-- this is backend exceptions[0].detail
        state["prompt_title"] = ""
        state["prompts"] = []
        state["ai_response_code"] = e.status_code or 500
        state["ai_response_type"] = "AURA"
        state["stage"] = "ERROR"

        requested = interrupt({
        "stage": state["stage"],
        "prompt": state["ai_response"],
        "prompt_title": state["prompt_title"],
        "prompts": state["prompts"],
        "ai_response_code": state["ai_response_code"],
        "ai_response_type": state["ai_response_type"],
        })
        state["csr_query"] = str(requested).strip()
        return state 

    if not providers:
        # Ask "No results -> try NPI?" via Horizon and INTERRUPT
        state["providers_result"] = None
        state["npi_origin"] = "fallback"
        state["npi_target_flow"] = "specialist"

        # Clear any old NPI state
        for k in ("npi_results_payload", "npi_mode", "npi_query", "provider_id_override"):
            state.pop(k, None)

        # Build the question with Horizon (no hardcoded sentence)
        sys = (
            "You are a CSR assistant.\n"
            "The specialist provider search returned no results.\n"
            "Ask the user if they would like to try the NPI Web search instead.\n"
            "Return ONLY the question text (no JSON, no markdown).\n"
            "The question must mention that no record was found for the provided input.\n"
        )
        search_basis = (state.get("specialist_raw_filter_input") or "").strip()
        user = f"No specialist provider record found for: {search_basis}"

        try:
            offer_q = call_horizon(sys, user).strip()
        except requests.exceptions.ReadTimeout:
            state["ai_response"] = getattr(settings, "TIMEOUT_ERROR_MESSAGE", "Request timed out. Please try again.")
            state["ai_response_type"] = "AURA"
            state["ai_response_code"] = 500
            state["prompt_title"] = ""
            state["prompts"] = []
            state["stage"] = "ERROR"
            return state

        mark_llm(state)

        #IMPORTANT: put the offer question into AIResponse and also into prompt
        state["ai_response"] = offer_q
        state["ai_response_type"] = "AURA"
        state["ai_response_code"] = 101
        state["prompt_title"] = ""
        state["prompts"] = ["Yes", "No"]
        state["stage"] = "SPECIALIST_NO_RESULTS_OFFER_NPI"

        requested = interrupt({
            "prompt": state["ai_response"],   # do not send empty prompt
            "stage": state["stage"],
            "prompt_title": state["prompt_title"],
            "prompts": state["prompts"],
            "ai_response_code": state["ai_response_code"],
            "ai_response_type": state["ai_response_type"],
        })

        state["csr_query"] = str(requested).strip()
        return state

    # Build grid JSON (same shape)
    grid_list: List[Dict[str, Any]] = []
    for p in (providers or []):
        prov_id = p.get("providerId") or ""
        name_val = p.get("name") or ""
        addr = _format_address_from_provider(p)

        raw_network = p.get("networkStatus") or ""
        raw_up = str(raw_network).upper()
        if raw_up in ("IN", "IN NETWORK"):
            net_str = "In Network"
        elif raw_up in ("OUT", "OUT NETWORK"):
            net_str = "Out Network"
        else:
            net_str = str(raw_network) if raw_network else ""

        grid_list.append({
            "ProviderID": str(prov_id),
            "Name": str(name_val),
            "Address": addr,
            "Network": net_str,
            "IsAcceptingNewMembers": p.get("isAcceptingNewMembers"),
            "PCPAssnInd": p.get("pcpAssnInd") or p.get("PCPAssnInd"),
            "DistanceInMiles": p.get("distance_mi") or p.get("distanceInMiles"),
        })

    response_payload = {"providers": grid_list}

    state["providers_result"] = providers
    state["ai_response"] = json.dumps(response_payload, default=str, separators=(",", ":"))
    state["ai_response_type"] = "AURA"
    state["ai_response_code"] = 107
    state["prompt_title"] = ""
    state["prompts"] = []
    state["stage"] = "SHOW_SPECIALIST_PROVIDER_LIST"

    requested = interrupt({"prompt": state["ai_response"], "stage": state["stage"]})
    state["csr_query"] = str(requested)
    return state
=============================
def route_after_specialist_search(state: PCPState) -> str:
    st = (state.get("stage") or "").strip().upper()

    if st == "GO_NPI":
        return "npi"

    if st in ("GO_MENU", "START", "MENU"):
        return "menu"

    if state.get("providers_result"):
        return "providers"

    return "stop"
