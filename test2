parsers.py
---------------

from typing import Dict, Any, List
import json
import logging
from app.llm.horizon_client import call_horizon

logger = logging.getLogger("pcp_app")

# ---- LLM-based parsers (no regex helpers) ----
def llm_validate_no_px_keys(filtered_case: Dict[str, Any]) -> Dict[str, Any]:
    system = (
        "You validate JSON objects.\n"
        "Check whether any key anywhere in the JSON starts with 'px' (case-insensitive).\n"
        "Return ONLY JSON:\n"
        "{\"has_px\": boolean, \"examples\": [\"pxKey1\", \"pxKey2\"]}\n"
        "examples should include up to 5 offending keys if any."
    )
    raw = call_horizon(system, json.dumps(filtered_case)[:12000])  # cap to avoid token blowups
    raw = raw.strip()
    if raw.startswith("```"):
        raw = raw.strip("`")
        i = raw.find("{")
        if i != -1:
            raw = raw[i:]
    try:
        return json.loads(raw)
    except Exception:
        return {"has_px": None, "examples": []}
    
def llm_extract_provider_query_from_assign_text(user_text: str) -> Dict[str, Any]:
    """
    Extract provider search query from a free-form 'assign ... as pcp' message.

    Returns ONLY JSON:
    {
      "search_type": "id" | "name_city_state" | "zip_only" | "unknown",
      "provider_id": string | null,
      "zip": string | null,
      "name": string | null,
      "city": string | null,
      "state": string | null
    }
    """
    system = (
        "You extract provider-identifying info from a user request that intends to assign a PCP.\n"
        "Return ONLY valid JSON with this schema:\n"
        "{\n"
        '  "search_type": "id" | "name_city_state" | "zip_only" | "unknown",\n'
        '  "provider_id": string | null,\n'
        '  "zip": string | null,\n'
        '  "name": string | null,\n'
        '  "city": string | null,\n'
        '  "state": string | null\n'
        "}\n"
        "Rules:\n"
        "- If there is an 8-digit provider id anywhere in the text, use search_type='id' and set provider_id.\n"
        "- Else if there is a provider name anywhere in the text (even if city/state/zip are NOT present), "
        "use search_type='name_city_state' and set name. city/state/zip may be null.\n"
        "- Else if there is a 5-digit ZIP and no provider id and no name, use search_type='zip_only' and set zip.\n"
        "- Ignore filler words like 'please', 'assign', 'as pcp', etc.\n"
        "Return JSON only."
    )

    raw = call_horizon(system, user_text).strip()
    if raw.startswith("```"):
        raw = raw.strip("`")
        i = raw.find("{")
        if i != -1:
            raw = raw[i:]
    try:
        data = json.loads(raw)
        st = (data.get("search_type") or "unknown").strip()
        if st not in ("id", "name_city_state", "zip_only"):
            st = "unknown"
        return {
            "search_type": st,
            "provider_id": data.get("provider_id"),
            "zip": data.get("zip"),
            "name": data.get("name"),
            "city": data.get("city"),
            "state": data.get("state"),
        }
    except Exception:
        logger.warning("Failed to parse assign-text provider JSON from LLM: %s", raw)
        return {
            "search_type": "unknown",
            "provider_id": None,
            "zip": None,
            "name": None,
            "city": None,
            "state": None,
        }
    
def llm_parse_zip_and_date(user_text: str) -> Dict[str, Any]:
    """
    Ask Horizon to extract optional ZIP code and as-of date from user's provider input text.

    Returns JSON:
    {
      "zip": string | null,        # 5-digit ZIP if present
      "as_of_date": string | null  # YYYYMMDD if present, else null
    }
    """
    system = (
        "You are an AI that extracts ZIP code and an as-of date from a member's free-text provider search request.<br>"
        "Return ONLY JSON with this schema:<br>"
        "{<br>"
        '  "zip": string | null,<br>'
        '  "as_of_date": string | null<br>'
        "}<br>"
        "Rules:<br>"
        "- zip must be exactly 5 numeric digits if present.<br>"
        "- as_of_date must be in YYYYMMDD format if present. If the user mentions a date in another format, "
        "  convert it to YYYYMMDD. If no date is mentioned, use null.<br>"
    )
    raw = call_horizon(system, user_text)
    raw = raw.strip()
    if raw.startswith("```"):
        raw = raw.strip("`")
        idx = raw.find("{")
        if idx != -1:
            raw = raw[idx:]
    try:
        data = json.loads(raw)
        zip_val = data.get("zip")
        as_of = data.get("as_of_date")
        return {
            "zip": zip_val,
            "as_of_date": as_of,
        }
    except Exception:
        logger.warning("Failed to parse ZIP/date JSON from LLM: %s", raw)
        return {"zip": None, "as_of_date": None}
    
def llm_parse_provider_input(user_text: str) -> Dict[str, Any]:
    system = (
        "You are an AI that extracts provider search parameters from free text.<br>"
        "Return ONLY valid JSON with this schema:<br>"
        "{<br>"
        '  "search_type": "id" | "name_city_state" | "zip_only",<br>'
        '  "provider_id": string | null,<br>'
        '  "zip": string | null,<br>'
        '  "name": string | null,<br>'
        '  "city": string | null,<br>'
        '  "state": string | null<br>'
        "}<br>"
        "Rules:<br>"
        "- If the input is ONLY an 8-digit number, it is a provider_id and search_type must be 'id'.<br>"
        "- If the input is ONLY a 5-digit number, it is a ZIP code and search_type must be 'zip_only'.<br>"
        "- If the user provides a provider name and city/state (optionally with zip), use search_type='name_city_state'.<br>"
        "- zip must be exactly 5 digits if present.<br>"
        "Return JSON only (no markdown, no explanation)."
    )
    raw = call_horizon(system, user_text).strip()
    if raw.startswith("```"):
        raw = raw.strip("`")
        idx = raw.find("{")
        if idx != -1:
            raw = raw[idx:]
    try:
        return json.loads(raw)
    except Exception:
        logger.warning("Failed to parse provider input JSON from LLM: %s", raw)
        # fallback: treat as name search (safer than calling provider_by_id incorrectly)
        return {
            "search_type": "name_city_state",
            "provider_id": None,
            "zip": None,
            "name": user_text.strip() or None,
            "city": None,
            "state": None,
        }


def llm_parse_filter_input(user_text: str) -> Dict[str, Any]:
    system = (
        "You are an AI that extracts PCP search filters from free text. "
        "Return ONLY JSON with this schema:<br>"
        "{<br>"
        '  "language": string | null,<br>'
        '  "radius_in_miles": number | null,<br>'
        '  "gender": "M" | "F" | null<br>'
        "}<br>"
        "Pick gender from M/F when user mentions male/female, man/woman, etc."
    )
    raw = call_horizon(system, user_text)
    raw = raw.strip()
    if raw.startswith("```"):
        raw = raw.strip("`")
        idx = raw.find("{")
        if idx != -1:
            raw = raw[idx:]
    try:
        data = json.loads(raw)
        return data
    except Exception:
        logger.warning("Failed to parse filter JSON from LLM: %s", raw)
        return {"language": None, "radius_in_miles": None, "gender": None}


def llm_decide_followup_action(user_text: str, providers: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Decide what user wants after seeing provider grid.
    Must detect:
      - provider_id_only: user sent only provider id (no other words)
      - address: user asks for address of a provider id
      - assign_pcp: user asks to assign provider as PCP
      - other
    Returns ONLY JSON:
      { "action": "provider_id_only"|"address"|"assign_pcp"|"other", "provider_id": string|null }
    """
    system = (
        "You are an assistant that interprets a member's follow-up message after they received a provider list.<br>"
        "Return ONLY JSON with this schema:<br>"
        "{<br>"
        '  "action": "provider_id_only" | "address" | "assign_pcp" | "other",<br>'
        '  "provider_id": string | null<br>'
        "}<br>"
        "Rules:<br>"
        "- If the message contains ONLY a provider id (just digits, no other words), action must be 'provider_id_only'.<br>"
        "- If the user asks for address/location of a provider, action='address'.<br>"
        "- If the user asks to assign a provider as PCP, action='assign_pcp'.<br>"
        "- provider_id must match one of the providerId values from the list when possible.<br>"
        "Return JSON only."
    )

    providers_brief = [
        {"providerId": str(p.get("providerId") or ""), "name": p.get("name")}
        for p in (providers or [])
    ]

    payload = {"message": user_text, "providers": providers_brief}
    raw = call_horizon(system, json.dumps(payload)).strip()

    if raw.startswith("```"):
        raw = raw.strip("`")
        idx = raw.find("{")
        if idx != -1:
            raw = raw[idx:]

    try:
        return json.loads(raw)
    except Exception:
        logger.warning("Failed to parse followup action JSON from LLM: %s", raw)
        return {"action": "other", "provider_id": None}

def llm_parse_no_flow_filters(user_text: str) -> Dict[str, Any]:
    """
    Extract NO-flow filter inputs from user text.

    Returns ONLY JSON:
    {
      "use_defaults": boolean,
      "language": string | null,          # e.g. "Spanish"
      "gender": "M" | "F" | null,         # normalize to M/F
      "zip": string | null,               # 5-digit
      "as_of_date": string | null,        # YYYYMMDD
      "radius_in_miles": number | null    # only if user explicitly wants change
    }
    """
    system = (
        "You are an AI that extracts PCP provider-search filters from text.\n"
        "Return ONLY valid JSON with this schema:\n"
        "{\n"
        '  "use_defaults": boolean,\n'
        '  "language": string | null,\n'
        '  "gender": "M" | "F" | null,\n'
        '  "zip": string | null,\n'
        '  "as_of_date": string | null,\n'
        '  "radius_in_miles": number | null\n'
        "}\n"
        "Rules:\n"
        "- If the user says 'Please proceed with the default values' (or same meaning), set use_defaults=true.\n"
        "- Otherwise use_defaults=false.\n"
        "- zip must be exactly 5 digits if present.\n"
        "- gender must be M or F when user implies male/female; if unclear use null.\n"
        "- If user provides a date in ANY format, convert to YYYYMMDD.\n"
        "- Only set radius_in_miles if the user explicitly asks to change the default distance.\n"
        "Return JSON only."
    )

    raw = call_horizon(system, user_text).strip()
    if raw.startswith("```"):
        raw = raw.strip("`")
        idx = raw.find("{")
        if idx != -1:
            raw = raw[idx:]

    try:
        data = json.loads(raw)
        # Defensive defaults
        return {
            "use_defaults": bool(data.get("use_defaults", False)),
            "language": data.get("language"),
            "gender": data.get("gender"),
            "zip": data.get("zip"),
            "as_of_date": data.get("as_of_date"),
            "radius_in_miles": data.get("radius_in_miles"),
        }
    except Exception:
        logger.warning("Failed to parse NO-flow filter JSON from LLM: %s", raw)
        return {
            "use_defaults": False,
            "language": None,
            "gender": None,
            "zip": None,
            "as_of_date": None,
            "radius_in_miles": None,
        }

def llm_route_menu_intent(user_text: str) -> str:
    """
    Returns: "assign_pcp" | "specialist" | "unsupported"
    Uses Horizon LLM so we can handle spelling mistakes and semantic variants.
    """
    system = (
        "You are an intent classifier for a health plan CSR assistant.\n"
        "Classify the user's menu choice into one of:\n"
        '- "assign_pcp"\n'
        '- "specialist"\n'
        '- "unsupported"\n'
        "Consider spelling mistakes and semantic variants.\n"
        "Return ONLY JSON like: {\"intent\":\"assign_pcp\"}\n"
    )
    raw = call_horizon(system, user_text).strip()
    if raw.startswith("```"):
        raw = raw.strip("`")
        idx = raw.find("{")
        if idx != -1:
            raw = raw[idx:]
    try:
        data = json.loads(raw)
        intent = str(data.get("intent") or "").strip()
        if intent in ("assign_pcp", "specialist", "unsupported"):
            return intent
        return "unsupported"
    except Exception:
        logger.warning("Failed to parse menu intent JSON from LLM: %s", raw)
        return "unsupported"

def llm_parse_specialist_filters(user_text: str) -> Dict[str, Any]:
    """
    Extract specialist search filters from text.

    Returns ONLY JSON:
    {
      "use_defaults": boolean,
      "language": string | null,
      "gender": "M" | "F" | null,
      "zip": string | null,
      "as_of_date": string | null,        # YYYYMMDD
      "radius_in_miles": number | null
    }
    """
    system = (
        "You are an AI that extracts Specialist provider-search filters from text.\n"
        "Return ONLY valid JSON with this schema:\n"
        "{\n"
        '  "use_defaults": boolean,\n'
        '  "language": string | null,\n'
        '  "gender": "M" | "F" | null,\n'
        '  "zip": string | null,\n'
        '  "as_of_date": string | null,\n'
        '  "radius_in_miles": number | null\n'
        "}\n"
        "Rules:\n"
        "- If the user says 'Please proceed with the default values' (or same meaning), set use_defaults=true.\n"
        "- Otherwise use_defaults=false.\n"
        "- zip must be exactly 5 digits if present.\n"
        "- gender must be M or F when user implies male/female; if unclear use null.\n"
        "- If user provides a date in ANY format, convert to YYYYMMDD.\n"
        "- Only set radius_in_miles if the user explicitly wants to change the default distance.\n"
        "Return JSON only."
    )

    raw = call_horizon(system, user_text).strip()
    if raw.startswith("```"):
        raw = raw.strip("`")
        idx = raw.find("{")
        if idx != -1:
            raw = raw[idx:]

    try:
        data = json.loads(raw)
        return {
            "use_defaults": bool(data.get("use_defaults", False)),
            "language": data.get("language"),
            "gender": data.get("gender"),
            "zip": data.get("zip"),
            "as_of_date": data.get("as_of_date"),
            "radius_in_miles": data.get("radius_in_miles"),
        }
    except Exception:
        logger.warning("Failed to parse Specialist filter JSON from LLM: %s", raw)
        return {
            "use_defaults": False,
            "language": None,
            "gender": None,
            "zip": None,
            "as_of_date": None,
            "radius_in_miles": None,
        }

========================================================

routing.py
----------------

from app.graph.state import PCPState
from app.llm.parsers import llm_route_menu_intent

def route_from_menu(state: PCPState) -> str:
    text = (state.get("csr_query") or "").lower().strip()

    if not text:
        return "unsupported"
    return llm_route_menu_intent(text)


def route_knows_provider(state: PCPState) -> str:
    if state.get("knows_provider"):
        return "knows"
    return "unknown"

def route_after_provider_followup(state: PCPState) -> str:
    if state.get("last_followup_action") == "assign_pcp":
        return "assign"
    if state.get("last_followup_action") == "provider_id_only":
        return "pid_only"
    return "loop"

def route_after_specialist_completion(state: PCPState) -> str:
    if state.get("stage") == "CLOSED":
        return "end"
    if state.get("stage") == "GO_MENU":
        return "menu"
    return "menu"

def route_after_specialist_provider_address(state: PCPState) -> str:
    # Only go to post-completion logic if we truly completed address inquiry
    if state.get("stage") == "COMPLETED":
        return "completed"
    return "loop"
